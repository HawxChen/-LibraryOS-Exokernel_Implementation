kern/lapic.c
    cpunum()
        Which CPU is code running on?
    lapic_startap()
        Startup IPI from the BSP to APs to bring up other CPUs
    apic_init()
        program LAPIC's built-in timer to trigger clock interrupts
        to support preemptive multitasking

mem_init_mp @ kern/pmap.c
    memory map for mp functionality

mp_init @ kern/mpconfig.c
    retrieve this information by reading the MP configuration table 
    that resides in the BIOS's region of memory

boot_aps @ kern/init.c
    drive the ap bootstrap processs. Activate APs one after another.

mp_main @ kern/init.c
    APs was setup, and APs will execute on this routine.

Questions:
    1. APs' init code should be in 4K byte aligment. But why is MPENTRY_PADDR = 0x7000?

    2. APs' init routine at address according to STARTUP | (0x7000 >> 12)
                                                           -------------
                                                                VV  ==> translate to CS:IP = VV00:0000h or 000VV000h 
                                                                                             or they are the same. 
    3.percpu_kstacks[NCPU][KSTKSIZE] <<< where to init it
       It is the global varable defined at kern/mpconfig.c.
       And map the CPU_i's kernel stack bottom's virtual address, into percpukstack[i]

    4.  at kern/mpentry.S
        4.1
	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movl    $mp_main, %eax
	call    *%eax
        Knowledge: xv6-ref.book
        Experiment: 1056 ~ 1061
        http://en.wikipedia.org/wiki/Addressing_mode#PC-relative_2
        4.2
        call    *%eax
        call    %eax
        call    (%eax)
        call    *(%eax)
        jmp     *%eax
        jmp     ...



    5.  What does the DS do?  
        In kern/mpentry.S:  Because this code sets DS to zero, it must run from an address in

    6.  env_free:
        Should It set the env_type back to ENV_TYPE_IDLE?
        ANS: No.

    7.  at sched_yield()
        //It is never returned here.
        //Compare it to co-routine scheduler in xv6
        //Does JOS have kernel scheduler thread?
        //Does xv6 have kernel scheduler thread?
        cprintf("CPU %d is back\n",cpunum());
        where does the kernel re-enter?

    8.  at sched_yield()
        Doesn't It put the following code before 'entering monitor section'?
        // Run this CPU's idle environment when nothing else is runnable.'
        if(cnt == NENV)
        {
            // Run this CPU's idle environment when nothing else is runnable.
            idle = &envs[cpunum()];
            if (!(idle->env_status == ENV_RUNNABLE || idle->env_status == ENV_RUNNING))
                panic("CPU %d: No idle environment!", cpunum());
            env_run(idle);
            //Compare it to co-routine scheduler in xv6
            //It is never returned here.
            cprintf("CPU %d is back\n",cpunum());
        }
    9.  In page_fault_handler:
        //In the recursive case, this means we have to leave
        // an extra word between the current top of the exception stack and
        // the new stack frame because the exception stack _is_ the trap-time
        // stack.
    10.Make sure you understand why user/faultalloc and user/faultallocbad behave differently.
        user/faultalloc.c is the recursive page fault.
        Just Look! lenth of 100 chars cross pages.
	cprintf("%s\n", (char*)0xCafeBffe);
	snprintf((char*) addr, 100, "this string was faulted in at %x", addr);

        
